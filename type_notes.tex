\documentclass{article}
\usepackage{mathtools,amssymb,amsthm}
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily,
    numbers=left,
    escapeinside={(*}{*)}
    }

\begin{document}

\section{The Howl Type Inference Algorithm}

Howl's type inference system works on a \textit{section} level.
While in the current implementation each section is one statement, it's possible that inferring types at the block level will be supported in the future, so the option is being left open.

To infer types for a section, the following algorithm is used:

\begin{enumerate}
    \item Initialize the section's \textit{type environment} $\Gamma$.

          Each expression or sub-expression receives a \textit{handle}, denoted $H_n$, which identifies it to the Howl compiler, and $\Gamma$ is a mapping from handles $H_n$ to types $T_n$.

          The initial types of each element of $\Gamma$ are determined by the \textit{setup rules}.
          Additionally, certain types of statement generate an additional handle $H_S$, also initialized to $\ast$.

    \item Repeatedly apply the typing rules.

          Each \textit{typing rule} specifies a set of source expressions or statements for which it is valid, a set of preconditions on the associated $T_n$ types that must be met for it to be applied, and the associated transformation it performs on the elements of $\Gamma$.

          Once no further typing rules can be applied to $\Gamma$, type inference terminates.

    \item Reduce the type objects generated by inference.

          Some type objects are not always in their simplest form.
          After inference completes, these can be \textit{reduced} using a set of reduction rules on each object to produce uniquely determined types.

    \item Associate the inferred types with their corresponding source expressions.

          Any expression that does not have an uniquely determined type associated with it is invalid.

\end{enumerate}

\section{Notation and Conventions}

Each setup rule is notated as a mapping $E \to T$ where $E$ represents a source statement or expression (possibly including handles for sub-expressions) and $T$ represents the type assignments to be generated from that statement or expression.

Each typing rule is notated as a mapping $\{C_0 \ldots C_n\} \to T$ where each $C_n$ represents a precondition and $T$ represents the rule's transformation.
Both the expression class and precondition sets may also be $\forall$, to represent that the rule applies to all classes of expressions or may always be applied.

Type constants from the original Howl program are typeset in \texttt{monospace}.

\section{Data Structures}

\subsection{Type Objects}

The result of the type inference algorithm is a mapping from expression handles to type objects representing their type.
Type objects admit the following operations:

\begin{itemize}
    \item equality $T_a = T_b$
    \item partial ordering or \textit{acceptance} $T_a \supseteq T_b$, representing that an object of type $T_b$ can be assigned to a location of type $T_a$
\end{itemize}

Unless otherwise stated, type objects are assumed to be not equal and not accepting.

\subsubsection{Error and Any}

The \textit{error type} $\emptyset$ represents the type of an invalid expression.
In general, any transformation on type inputs including $\emptyset$ will also result in $\emptyset$.
The semantically similar \textit{any type} $\ast$ represents the type of an expression that has not yet had types inferred for it, or the type of an unconstrained parameter input.

Equality: $\emptyset = \emptyset$,\quad$\ast = \ast$

Ordering: $\forall T:\: T \not= \emptyset,\:\emptyset \not\supseteq T,\quad\forall T: \ast \supseteq T$

\subsubsection{Type Constants}

A type constant represents a single type from the original program, such as \texttt{i32} or \texttt{root.lib.String}.

Equality: Two type constants are equal if their string representations are equal.

Ordering: A type constant $T_a$ accepts another type constant $T_b$ if and only if:

\begin{itemize}
    \item $T_a$ and $T_b$ both represent numeric types, or
    \item $T_a$ represents a superclass of $T_b$, or
    \item $T_a$ represents an interface implemented by $T_b$.
\end{itemize}

\subsubsection{Type Aliases}

A type alias represents the type of another handle, notated $[H_n]$.

\subsubsection{Intersection Types}

An intersection type represents the most general type accepted by two subtypes, notated $(T_a \cap T_b)$.

\subsubsection{Union Types}

An union type represents a type that may take on one of two different values depending on some to-be-determined condition, notated $(T_a \cup T_b)$.

\section{Setup Rules}

\subsection{Assignment and Initialization}

\begin{align*}
    H_{lhs} \texttt{ = } H_{rhs}\texttt{;}\:             & \to H_{lhs} \mapsto (\Gamma_{H_{lhs}} \cap \Gamma_{H_{rhs}}), H_{rhs} \mapsto [H_{lhs}] \\
    \texttt{let }T_{def}\texttt{ = }H_{init}\texttt{;}\: & \to H_{init} \mapsto (\Gamma_{H_{init}} \cap T_{def}), H_S \mapsto [H_{init}]
\end{align*}

\subsection{Constants}

\begin{align*}
    H_n:\:<\textrm{numeric literal}>\: & \to H_n \mapsto \mathtt{numeric}   \\
    H_n:\:<\textrm{string literal}>\:  & \to H_n \mapsto \star(\mathtt{u8})
\end{align*}

\section{Typing Rules}

\subsection{Alias Dereferencing}

\begin{equation*}
    [H_{a}]\::\:\Gamma_{H_a}\textrm{ is uniquely determined} \to \Gamma_{H_{a}}
\end{equation*}

\subsection{Intersection Failure}

\begin{equation*}
    T_a \cap T_b\::\:(T_a \not\supseteq T_b) \vee (T_b \not\supseteq T_a) \to \emptyset
\end{equation*}

\subsection{Union-Intersection Resolution}

\begin{equation*}
    T_a \cap (T_a \cup T_b) \to T_a
\end{equation*}

\section{Examples}

\end{document}
